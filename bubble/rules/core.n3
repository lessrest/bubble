@prefix : <#> .
@prefix eye: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix nt: <https://node.town/2024/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix swa: <https://swa.sh/> .

# Define inverse relationships
nt:owns owl:inverseOf nt:isOwnedBy .
nt:succeeds owl:inverseOf nt:precedes .
nt:isPartOf owl:inverseOf nt:hasPart .
owl:inverseOf owl:inverseOf owl:inverseOf .

# Rule: Apply inverse relationships
{
   ?p owl:inverseOf ?q .
   ?a ?p ?b 
}
=> 
{
   ?b ?q ?a 
} .

# Rule: Apply suppositions
{
   nt:nonce nt:ranks ?rank .
   ?step nt:ranks ?rank .
   ?step nt:supposes ?g 
}
=> ?g .

# Rule: Calculate next state from current state
# next = current + decisions - revocations
{
   ?s1 a nt:Step .
   ?s2 nt:succeeds ?s1 .
   [] eye:findall (
       ?g1
       {
           ?s1 nt:supposes ?g1 
       }
       ?gs1
   ) ;
       eye:findall (
           ?g2
           {
               ?s1 nt:decides ?g2 
           }
           ?gs2
       ) ;
       eye:findall (
           ?g3
           {
               ?s1 nt:revokes ?g3 
           }
           ?gs3
       ) .
   ?gs1 log:conjunction ?g1m .
   ?gs2 log:conjunction ?g2m .
   ?gs3 log:conjunction ?g3m .
   ( ?g1m ?g3m ) eye:graphDifference ?tmp .
   ( ?tmp ?g2m ) log:conjunction ?result .
}
=> 
{
   ?s2 nt:supposes ?result 
} .

# Rule: Increment nonce
{
   nt:nonce nt:ranks ?rank .
   ?step nt:ranks ?rank .
   ?next nt:succeeds ?step .
   ( ?rank 1 ) math:sum ?incr 
}
=> 
{
   ?step nt:decides 
   {
       nt:nonce nt:ranks ?incr .
       ?next nt:ranks ?incr .
   } .
   ?step nt:revokes 
   {
       nt:nonce nt:ranks ?rank 
   } .
} .
