Dissertation by [[Roy Fielding]], 2000.

## Chapter 6: Experience and Evaluation Since 1994

### 6.3.4 REST Mismatches in HTTP

There are several architectural mismatches present within HTTP, some due to
3rd-party extensions that were deployed external to the standards process and
others due to the necessity of remaining compatible with deployed HTTP/1.0
components.

#### 6.3.4.1 Differentiating Non-authoritative Responses

One weakness that still exists in HTTP is that there is no consistent
mechanism for differentiating between authoritative responses, which are
generated by the origin server in response to the current request, and
non-authoritative responses that are obtained from an intermediary or cache
without accessing the origin server. The distinction can be important for
applications that require authoritative responses, such as the safety-critical
information appliances used within the health industry, and for those times
when an error response is returned and the client is left wondering whether
the error was due to the origin or to some intermediary. Attempts to solve
this using additional status codes did not succeed, since the authoritative
nature is usually orthogonal to the response status. responses, such as the
safety-critical information appliances used within the health industry, and
for those times when an error response is returned and the client is left
wondering whether the error was due to the origin or to some intermediary.
Attempts to solve this using additional status codes did not succeed, since
the authoritative nature is usually orthogonal to the response status.

HTTP/1.1 did add a mechanism to control cache behavior such that the desire
for an authoritative response can be indicated. The 'no-cache' directive on a
request message requires any cache to forward the request toward the origin
server even if it has a cached copy of what is being requested. This allows a
client to refresh a cached copy which is known to be corrupted or stale.
However, using this field on a regular basis interferes with the performance
benefits of caching. A more general solution would be to require that
responses be marked as non-authoritative whenever an action does not result in
contacting the origin server. A Warning response header field was defined in
HTTP/1.1 for this purpose (and others), but it has not been widely implemented
in practice.

#### 6.3.4.2 Cookies

An example of where an inappropriate extension has been made to the protocol to support features that contradict the desired properties of the generic interface is the introduction of site-wide state information in the form of [[HTTP Cookie]]s. Cookie interaction fails to match [[REST]]'s model of application state, often resulting in confusion for the typical browser application. ^cookies-bad

An HTTP cookie is opaque data that can be assigned by the origin server to a user agent by including it within a `Set-Cookie` response header field, with the intention being that the user agent should include the same cookie on all future requests to that server until it is replaced or expires. Such cookies typically contain an array of user-specific configuration choices, or a token to be matched against the server's database on future requests. 

_The problem is that a cookie is defined as being attached to any future requests for a given set of resource identifiers, usually encompassing an entire site, rather than being associated with the particular application state (the set of currently rendered representations) on the browser._

When the browser's history functionality (the "Back" button) is subsequently used to back-up to a view prior to that reflected by the cookie, the browser's application state no longer matches the stored state represented within the cookie. Therefore, the next request sent to the same server will contain a cookie that misrepresents the current application context, leading to confusion on both sides.

Cookies also violate REST because they allow data to be passed without sufficiently identifying its semantics, thus becoming a concern for both security and privacy. The combination of cookies with the `Referer` (sic) header field makes it possible to track a user as they browse between sites.

As a result, _cookie-based applications on the Web will never be reliable_. The same functionality should have been accomplished via anonymous authentication and true client-side state. A state mechanism that involves preferences can be more efficiently implemented using judicious use of context-setting URI rather than cookies, where judicious means _one URI per state_ rather than an unbounded number of URI due to the embedding of a user ID. Likewise, the use of cookies to identify a user-specific "shopping basket" within a server-side database could be more efficiently implemented by defining the semantics of shopping items within the hypermedia data formats, allowing the user agent to select and store those items within their own client-side shopping basket, complete with a URI to be used for check-out when the client is ready to purchase. ^instead-of-cookies
