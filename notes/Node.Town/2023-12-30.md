I broke my arm the other day. This gives me some motivation to make a working program, because I need it. I want to be able to chat with my brother over text via voice in a way that also lets us work with AI tools.

I set up an instance on [[Fly.io]] but it's not really useful. I want to get [[ActivityPub]] working in real time with [[Speech Recognition]] and [[Software Agents]].

Now I set up the [[swa.sh]] domain as an alias to the Fly.io instance.

I notice that I'm a bit afraid of running the speech recognition thing because I have a felt sense of fear that it's spamming my database, etc. This may be true. I'm not sure exactly what it does.

It would be really cool if I saw an affordance on my thing that said like create a new chat or whatever, and then like I could do that and it would take me to like something like an empty graph and there could invite people or you know like I could create an identity you know or like create participant, so I would create a participant for myself and then I would create a participant for Daniel and that would give me a link that I could send to Daniel which would like take him to the chat with the Daniel identity. We can then each do Voice input and they would show up like on a timeline in real time so a real time transcription appearing as chat.

I also wanna be able to configure a secrets like API keys through the graph database because I set up a persistent volume on fly.io so I can use that to store the secrets instead of environment variables. 

At some point I will also need to handle replication so multiple instances of the app running at the same time for in a rolling deploys and for just redundancy and I wonder how that is gonna work that is very interesting. It should just be two instances with different repositories but synchronizing amongst each other and they don't need to synchronize temporary graphs they only need to synchronize the transaction graphs or the persistent graphs. And they could also connect to each other with live sockets web sockets I mean to expose each other's agents so it's just an application of the mesh. 

So now I have multiple instances multiple machines running on fly.io so when you refresh the website you see randomly you get different note IDs and I learned about how to implement clustering you just do DNS look up of an internal DNS name like app name.internal and that'll give you a list of all the machines and then you can just like do that once every five seconds and implement some kind of clustering thing and I already have some kind of code for connecting notes to each other but I don't think I have implemented so that like one web server can connect to another and integrate so I need to do that that also means doing RDF replication I think but I have to think about that a little bit more.

I'm getting really good at using dictation and voice control in macOS and it's really cool because I'm just standing up right now and I am dictating I can switch between applications it's very useful but I'm still getting the hang of the commands.

I am very interested in accessibility and discovering which apps in which websites are not accessible and their problems for example telegram is not an accessible app it doesn't like expose any names for widgets and stuff so it's quite annoying to use. Twitter website is also not very accessible and it just has too many widgets that are confusing to use.

So it's a main priority to make the swash user interface accessible using voice and other accessibility paradigm screen readers and so on. And it's kind of good that I have this handicap because it forces me to actually make this work.

So swash is now by definition of accessible platform and I have to learn something about Web accessibility.

Thinking about how to implement the actor mesh cluster thingy let's say we have started two instances of the app they both have the same base URL configured but they have different key pairs because they have different repos what do we wanna accomplish well if they're running on the same base URL that means they should be like transparently hooked up to each other so that any URL that would work on one instance would also work on the other instances and you should get the same results other than you know some minor like you you would be able to see which note you are on maybe but you still get basically the same resources cause that's you know that's the semantics of the web U RRL needs to you know going to the same thing no matter which server accept the request.

So it kind of means that when you connect to servers maybe this is like a special mode of connection where you are trying to fuse to act as one if you keep the art data synchronized by replicating you know by synchronizing the repositories and doing live replication that takes care of Data and like viewing resources but it doesn't take care of actor Communication.

It's also interesting to consider how for example when we start the server now we start several actors that have these capabilities and it seems kind of weird to start multiple of those cause then for example you would see like multiple affords maybe or maybe not because they are scoped to the node in the interface you would see only the ones that belong to the note of the current server it's a little bit weird innocent interesting thing to think about you may well want to have duplicates of them maybe that's the whole point cause if one server goes down you wanna be able to use the other server that is the whole point but you can also imagine a mode where you would want to run actors the provide services for capabilities which are not duplicated on all web server nodes.

So this is related to names, permanence, identity. Seems like we will want to have a thing where we can define like we want to have an actor like a multiplex actress or whatever

I just now started thinking about using actor bus no I mean a message bus kind of thing for doing the vet clustering I think for the clustering it's less important to have security because we're assuming that we are trusted cluster and anyway on the internal network we're not gonna have certificates and TLS and stuff but maybe this is just adding more technology for no good reason. Think about why I would do this cause you can get like the mesh thing kind of for free if you use MQTT and then we would have like one machine running the hub and you don't need to do all that peer connections or maybe like one machine per region or whatever makes a lot of sense.